name: openbacklog

services:
  fastapi:
    build:
      dockerfile: docker/fastapi.Dockerfile
      args:
        - CLUSTER_NAME=${CLUSTER_NAME}
    ports:
      - "${FASTAPI_PORT}:8000"
    env_file:
      - .env.cluster-dev
    environment:
      # Computed database URLs that reference Docker service hostname
      - database_url=postgresql://${database_app_user_username}:${database_app_user_password}@postgres:5432/${database_name}
      - async_database_url=postgresql+asyncpg://${database_app_user_username}:${database_app_user_password}@postgres:5432/${database_name}
    volumes:
      - ${CLUSTER_NAME:-dev}-secrets:/app/secrets
      - ${CLUSTER_NAME:-dev}-uploads:/app/uploads
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "python", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8000/healthcheck')"]
      interval: 60s
      timeout: 10s
      retries: 3
      start_period: 60s

  postgrest:
    image: postgrest/postgrest:v12.2.8
    ports:
      - "${POSTGREST_PORT}:3000"
    env_file:
      - .env.cluster-dev
    environment:
      # Computed connection string that references Docker service hostname
      - PGRST_DB_URI=postgres://${postgrest_authenticator__role}:${postgrest_authenticator__password}@postgres:5432/${POSTGRES_DB}

    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - app-network

  postgres:
    image: postgres:16
    ports:
      - "${POSTGRES_PORT}:5432"
    shm_size: 128mb
    volumes:
      - ${CLUSTER_NAME:-dev}-postgres-data:/var/lib/postgresql/data
      - ./docker/postgres-init.sql:/docker-entrypoint-initdb.d/01-init.sql
    env_file:
      - .env.cluster-dev
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER:-postgres} -d $${POSTGRES_DB:-postgres}"]
      interval: 5s
      timeout: 3s
      retries: 5
      start_period: 10s
    networks:
      - app-network


volumes:
  # ============================================================================
  # Multi-Cluster Volume Strategy
  # ============================================================================
  # Each service volume is dynamically named using ${CLUSTER_NAME:-dev}
  # This enables complete isolation between clusters.
  #
  # Volume naming conventions:
  #   - dev-postgres-data (primary cluster)
  #   - agent-1-postgres-data (agent cluster 1)
  #   - agent-2-postgres-data (agent cluster 2)
  #   - etc.
  #
  # Data volumes (postgres) are declared for all supported clusters.
  # Secrets volumes are pre-defined for each cluster to ensure file permissions
  # and isolation. Applications mount these volumes at /app/secrets.
  # ============================================================================

  # Primary "dev" cluster data volumes
  dev-postgres-data:
  dev-uploads:

  # Agent cluster 1 data volumes
  agent-1-postgres-data:
  agent-1-uploads:

  # Agent cluster 2 data volumes
  agent-2-postgres-data:
  agent-2-uploads:

  # Agent cluster 3 data volumes
  agent-3-postgres-data:
  agent-3-uploads:

  # Long-living cluster data volumes (for dog-fooding)
  longliving-postgres-data:
  longliving-uploads:

  # Secrets volumes (pre-defined for each cluster)
  # These store encrypted credentials and API keys
  dev-secrets:
  agent-1-secrets:
  agent-2-secrets:
  agent-3-secrets:
  longliving-secrets:

networks:
  app-network:
    driver: bridge
    name: ${DOCKER_NETWORK_NAME}
