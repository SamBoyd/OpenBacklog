services:
  nginx:
    image: nginx:stable-alpine
    ports:
      - "${NGINX_PORT}:80"
    volumes:
      - ./nginx.conf.template:/etc/nginx/conf.d/default.conf.template:ro
    environment:
      - APP_DOMAIN=${app_domain}
      - DOCKER_NETWORK_NAME=${DOCKER_NETWORK_NAME}
    entrypoint: /bin/sh
    command: -c "
      CLUSTER_NAME=$${DOCKER_NETWORK_NAME%%-net} &&
      echo 'APP_DOMAIN=${app_domain}' &&
      echo 'CLUSTER_NAME='$$CLUSTER_NAME &&
      sed -e 's|@APP_DOMAIN@|${app_domain}|g' -e 's|@CLUSTER_NAME@|'$$CLUSTER_NAME'|g' /etc/nginx/conf.d/default.conf.template > /etc/nginx/conf.d/default.conf &&
      echo '=== Rendered nginx config ===' &&
      cat /etc/nginx/conf.d/default.conf &&
      echo '=== Testing nginx config ===' &&
      nginx -t &&
      echo '=== Starting nginx ===' &&
      nginx -g 'daemon off;'
      "
    depends_on:
      - fastapi
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost/healthcheck"]
      interval: 5s
      timeout: 10s
      retries: 3
      start_period: 10s

  fastapi:
    build:
      context: ..
      dockerfile: docker/fastapi.Dockerfile
      args:
        - CLUSTER_NAME=${CLUSTER_NAME}
    ports:
      - "${FASTAPI_PORT}:8000"
    env_file:
      - ../.env.development
    environment:
      # Computed database URLs that reference Docker service hostname
      - database_url=postgresql://${database_app_user_username}:${database_app_user_password}@postgres:5432/${database_name}
      - async_database_url=postgresql+asyncpg://${database_app_user_username}:${database_app_user_password}@postgres:5432/${database_name}
    volumes:
      - ${CLUSTER_NAME:-dev}-secrets:/app/secrets
      - ${CLUSTER_NAME:-dev}-uploads:/app/uploads
      # Preserve build artifacts from Docker image (more specific mounts take precedence)
      - /app/static/react-components
    depends_on:
      # litellm_proxy:
      #   condition: service_healthy
      postgres:
        condition: service_healthy
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "python", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8000/healthcheck')"]
      interval: 5s
      timeout: 10s
      retries: 3
      start_period: 40s

  postgrest:
    image: postgrest/postgrest:v12.2.8
    ports:
      - "${POSTGREST_PORT}:3000"
    env_file:
      - ../.env.development
    environment:
      # Computed connection string that references Docker service hostname
      - PGRST_DB_URI=postgres://${postgrest_authenticator__role}:${postgrest_authenticator__password}@postgres:5432/${POSTGRES_DB}

    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - app-network

  postgres:
    image: postgres:16
    ports:
      - "${POSTGRES_PORT}:5432"
    shm_size: 128mb
    volumes:
      - ${CLUSTER_NAME:-dev}-postgres-data:/var/lib/postgresql/data
      - ./postgres-init.sql:/docker-entrypoint-initdb.d/01-init.sql
    env_file:
      - ../.env.development
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER:-postgres} -d $${POSTGRES_DB:-postgres}"]
      interval: 5s
      timeout: 3s
      retries: 5
      start_period: 10s
    networks:
      - app-network


volumes:
  # ============================================================================
  # Multi-Cluster Volume Strategy
  # ============================================================================
  # Each service volume is dynamically named using ${CLUSTER_NAME:-dev}
  # This enables complete isolation between clusters.
  #
  # Volume naming conventions:
  #   - dev-postgres-data (primary cluster)
  #   - agent-1-postgres-data (agent cluster 1)
  #   - agent-2-postgres-data (agent cluster 2)
  #   - etc.
  #
  # Data volumes (postgres) are declared for all supported clusters.
  # Secrets volumes are pre-defined for each cluster to ensure file permissions
  # and isolation. Applications mount these volumes at /app/secrets.
  # ============================================================================

  # Primary "dev" cluster data volumes
  dev-postgres-data:
  dev-uploads:

  # Agent cluster 1 data volumes
  agent-1-postgres-data:
  agent-1-uploads:

  # Agent cluster 2 data volumes
  agent-2-postgres-data:
  agent-2-uploads:

  # Agent cluster 3 data volumes
  agent-3-postgres-data:
  agent-3-uploads:

  # Secrets volumes (pre-defined for each cluster)
  # These store encrypted credentials and API keys
  dev-secrets:
  agent-1-secrets:
  agent-2-secrets:
  agent-3-secrets:

networks:
  app-network:
    driver: bridge
    name: ${DOCKER_NETWORK_NAME}
